<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>js原型和继承</title>
</head>
<body>
	<h1>js对象创建</h1>
	<p>方法一 Object</p>
	<textarea name="" id="" cols="120" rows="10">
	var o1 = {};//字面量的表现形式
	var o2 = new Object;
	var o3 = new Object();
	var o4 = new Object(null);
	var o5 = new Object(undefined);
	var o6 = Object.create(Object.prototype);//等价于 var o = {};//即以 Object.prototype 对象为一个原型模板,新建一个以这个原型模板为原型的对象
	//区别
	var o7 = Object.create(null);//创建一个原型为 null 的对象
	</textarea>
	<p>方法二 工厂模式</p>
	<p>缺点在于函数不共享,都需要单独开辟内存</p>
	<textarea name="" id="" cols="120" rows="10">
	function Fruit(){
		var o1 = new Object;
		var age = 13;
		o1.name = "lokia";
		o1.getAge = function(){
			return age;
		}
	return o1;
 }
	</textarea>
	<p>方法三 构造器加原始模式创建对象</p>
	<p>单纯的构造器模式函数无法共享，单纯的原型模式每个实例化得对象变量都不完全属于对方，其他实例改变变量时，所有的变量都改变</p>
	<textarea name="" id="" cols="120" rows="12">
	function Animal(){
		this.name = 'Animal';
		this.setName = function(name){
			this.name = name;
		}
	}

	Animal.prototype.run = function() {
		console.log('I am runnig');
	}
	</textarea>

	<h1>js对象继承</h1>
	<p>讲道理好的继承方式只有一种吧</p>
	<textarea name="" id="" cols="120" rows="30">
	function Animal(){
		this.name = 'Animal';
		this.setName = function(name){
			this.name = name;
		}
	}

	Animal.prototype.run = function() {
		console.log('I am runnig');
	}

	function Dog(){
		Animal.apply(this);//获得构造器里的属性和方法，使Dog函数拥有这些属性，不单单是能使用
	}

	Dog.prototype = new Animal();//获得animal函数上prototype上的函数

	var dog = new Dog();

	console.log(dog.name);
	dog.setName('dog');
	console.log(dog.name);
	dog.run();
	</textarea>


	
</body>
<script src="index.js"></script>
</html>